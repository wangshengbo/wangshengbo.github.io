{"meta":{"title":"Oliver's Blog","subtitle":"根本没有正确的选择，只能靠奋斗来使当初的选择显的正确","description":"王圣博的个人博客","author":"Oliver","url":"http://wangshengbo.me"},"pages":[{"title":"about","date":"2017-09-29T12:11:00.000Z","updated":"2017-09-29T12:11:00.485Z","comments":true,"path":"about/index.html","permalink":"http://wangshengbo.me/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Java数据类型、进制和位运算学习总结","slug":"Java数据类型、进制和位运算学习总结","date":"2017-10-06T06:49:10.467Z","updated":"2017-10-06T06:50:46.522Z","comments":true,"path":"2017/10/06/Java数据类型、进制和位运算学习总结/","link":"","permalink":"http://wangshengbo.me/2017/10/06/Java数据类型、进制和位运算学习总结/","excerpt":"","text":"基本数据类型Java中的基础类型有：byte、short、int、long、float、double、char和boolean它们可被分为四种类型，整型、浮点型、char型和boolean型 整型：byte、short、int、long 分别占用1、2、4、8个字节的空间 浮点型：float、double 分别占用4、8个字节 char型：char 占用2个字节 boolean型：boolean《Java虚拟机规范》指出单独使用是4个字节，在数组中又是1个字节，但是不对应任何整数值 每种数值类型的最大表示范围可以通过包装类的静态属性取到，比如Integer.MAX_VALUE，Integer.MIN_VALUE 原文链接 进制在Java中整型数据有8进制、10进制或者16进制3种表示方法，不能直接使用2进制表示数字十进制：用多个0~9的数字表示，首位不能为0八进制：以数字0开头，后面跟多个0~7的数字。但是，当使用八进制数据表示转义字符时不能用0开头，例如：\\ddd十六进制：以0x或0X开头，后跟多个0~9的数字或者a~f的大写或小写字母。但是，当使用十六进制数据表示转义字符时不能用0x开头，例如：\\udddd10进制数有正负之分，但8进制和16进制只能用来表达无符号的整数 进制转换二进制数在计算机中是以补码形式保存的，正数的原码、反码、补码都是一样的，而负数的补码是其反码加1 十进制与二进制的转换负整数由十进制转换为二进制的步骤为：取反，加1。例如：将-5转换为二进制的步骤如下：首先，5的二进制为101，扩展到32位为00000000 00000000 00000000 00000101，取反之后为11111111 11111111 11111111 11111010，加1之后就是11111111 11111111 11111111 11111011，这就是-5的二进制表示。负整数由二进制转换成十进制也是一样的步骤：取反，加1。继续用上面的例子，-5的二进制11111111 11111111 11111111 11111011取反之后为00000000 00000000 00000000 00000100，加1为00000000 00000000 00000000 00000101，这个二进制的值是5，而最初的二进制数的第一位是1，表示负数，因此转换之后是-5。原文链接 Java转换函数1.十进制转其他进制 Integer.toBinaryString(int i)返回i的二进制字符串表示 Integer.toHexString(int i)返回i的十六进制字符串表示 Integer.toOctalString(int i)返回i的八进制字符串表示 Integer.toString(int i, int radix)返回i的radix进制表示 代码 System.out.println(&quot;--二进制--&quot;); System.out.println(Integer.toBinaryString(20)); System.out.println(Integer.toString(20,2)); System.out.println(Integer.toBinaryString(-20)); System.out.println(Integer.toString(-20,2)); System.out.println(&quot;--八进制--&quot;); System.out.println(Integer.toOctalString(20)); System.out.println(Integer.toString(20,8)); System.out.println(Integer.toOctalString(-20)); System.out.println(Integer.toString(-20,8)); System.out.println(&quot;--十六进制--&quot;); System.out.println(Integer.toHexString(20)); System.out.println(Integer.toString(20,16)); System.out.println(Integer.toHexString(-20)); System.out.println(Integer.toString(-20,16)); 结果 --二进制-- 10100 10100 11111111111111111111111111101100 -10100 --八进制-- 24 24 37777777754 -24 --十六进制-- 14 14 ffffffec -14 当十进制数为正时，toString()的结果和其他3个函数一样，当值为负时，toString()的结果是直接在正值的结果前面加“-” 2.其他进制转十进制 Integer.parseInt(String s, int radix) Integer.valueOf(String s, int radix)与上一函数结果相同，内部直接调用了上一函数 但是需要注意，这两个函数与上面的Integer.toString(int i, int radix)的操作是相反的，参数s是“-101”这种形式的，不是真正的二进制（或八进制、十六进制）表示 代码 System.out.println(Integer.parseInt(&quot;-1010&quot;,2)); System.out.println(Integer.parseInt(&quot;-10000000000000000000000000000000&quot;,2)); System.out.println(Integer.parseInt(&quot;-0&quot;,2)); System.out.println(Integer.parseInt(&quot;-12&quot;,8)); System.out.println(Integer.parseInt(&quot;-a&quot;,16)); 结果 -10 -2147483648 0 -10 -10 原文链接 位运算基本概念位运算是对整数中的位进行测试、置位或移位处理，是对数据进行按位操作的手段Java的位操作数只限于字符和整数，对char、byte或者short进行移位处理时，系统会先将它们转换成一个int，然后再进行移位处理移位运算速度高于乘除运算若进行位逻辑运算的两个操作数的数据长度不相同，则返回值是数据长度较长的数据类型 位运算符~的优先级最高，其次是&lt;&lt;、&gt;&gt;和&gt;&gt;&gt;，再次是＆，然后是^，优先级最低的是| &amp; —— 按位进行与运算例如：1100&amp;1010=1000可以用0来屏蔽特定的位，也可以用1来取某个数型数中某些特定的位 ~ —— 按位进行取反运算 | —— 按位进行或运算例如：1100|1010=1110可以用1来对某个整型数的特定位的值置1 ^ —— 按位进行异或运算例如：1100^1010=0110数a两次异或同一个数b（a=a^b^b）仍然为原值a &lt;&lt; —— 按位左移 运算符左侧对象左移由右侧指定的位数，低位补0，最高位抛弃 带符号的左移位运算相当于对左操作数进行乘2运算 如果移动的位数超过了该类型的最大位数，那么编译器会对移动的位数取模。如对int型移动33位，实际上只移动了33%32=1位。 如果移进符号位，那么该值将变为负值 &gt;&gt; —— 按位右移运算符左侧对象右移由右侧指定的位数若值为正，在最高位插入0；若值为负，在最高位插入1，即移入的最高位和原最高符号位相同带符号的右移位运算相当于对左操作数进行除2运算 &gt;&gt;&gt; —— 按位进行无符号右移无论运算符左边的运算对象取值正负，都在最高位插入0 位运算的应用 判断int型变量a是奇数还是偶数a&amp;1 = 0 偶数a&amp;1 = 1 奇数 取int型变量a的第k位 (k=0,1,2……sizeof(int))，即 a &gt;&gt; k &amp; 1 将int型变量a的第k位清0，即 a = a &amp; ~ (1 &lt;&lt; k) 将int型变量a的第k位置1，即 a = a | (1 &lt;&lt; k) 将int型变量a循环左移k次，即 a = a &lt;&lt; k | a &gt;&gt; 32 - k 将int型变量a循环右移k次，即 a = a &gt;&gt; k | a &lt;&lt; 32 - k 求整数的平均值对于两个整数x,y，如果用(x+y)/2求平均值，会产生溢出，因为x+y可能会大于INT_MAX，但是我们知道它们的平均值是肯定不会溢出的，我们用如下算法： int average(int x, int y) //返回X,Y的平均值 { return (x&amp;y)+((x^y)&gt;&gt;1); } 注意结果仅保留整数 可以不使用临时变量完成两个值的交换，也可以使某个整型数的特定位的值翻转（0对应的位置不翻转，1对应的位置翻转）代码 int a = 1; int b = 2; a ^= b; b ^= a; a ^= b; System.out.println(&quot;a=&quot;+a+&quot; b=&quot;+b); 结果 a=2 b=1 对于一个数 x &gt; 0，判断他是不是2的幂 boolean power2(int x) { return ((x&amp;(x-1))==0)&amp;&amp;(x!=0)； } 计算绝对值 int abs( int x ) { int y ; y = x &gt;&gt; 31 ; return (x^y)-y ; //or: (x+y)^y } x 的相反数表示为 ~x + 1 给x赋值为a或b中的一个 if (x == a) x = b; if (x == b) x = a; 等价于 x = a ^ b ^ x原文链接 最后附上位操作技巧的一篇英文文章：Bit Twiddling Hacks","categories":[],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://wangshengbo.me/tags/Java基础/"},{"name":"数据类型","slug":"数据类型","permalink":"http://wangshengbo.me/tags/数据类型/"},{"name":"进制转换","slug":"进制转换","permalink":"http://wangshengbo.me/tags/进制转换/"},{"name":"位运算","slug":"位运算","permalink":"http://wangshengbo.me/tags/位运算/"}],"keywords":[]},{"title":"正整数划分问题","slug":"正整数划分问题","date":"2017-10-03T12:21:01.640Z","updated":"2017-10-03T12:22:22.000Z","comments":true,"path":"2017/10/03/正整数划分问题/","link":"","permalink":"http://wangshengbo.me/2017/10/03/正整数划分问题/","excerpt":"","text":"正整数划分问题，题目描述如下： 将正整数n表示成一系列正整数之和：n=n1+n2+…+nk，其中n1≥n2≥…≥nk≥1，k≥1。 正整数n的这种表示称为正整数n的划分。求正整数n的不同划分个数。 例如正整数6有如下11种不同的划分： 6； 5+1； 4+2，4+1+1； 3+3，3+2+1，3+1+1+1； 2+2+2，2+2+1+1，2+1+1+1+1； 1+1+1+1+1+1 分析：使用递归进行求解，需设置另一个参数m辅助求解递归函数共有两个参数，一个是n，代表待求解的正整数；另一个是m，代表正整数n的划分中最大的数 Java代码 public class IntegerDivide { public static void main(String[] args) throws IOException { BufferedReader sc = new BufferedReader(new InputStreamReader(System.in)); String str; while ((str = sc.readLine()) != null) { int n = Integer.parseInt(str); System.out.println(integerDivide(n, n)); } } public static long integerDivide(int n, int m) { if (n &lt; 1 || m &lt; 1) return 0; if (m == n) return (integerDivide(n, m - 1) + 1); if (n == 1 || m == 1) { return 1; } if (n &lt; m) { return integerDivide(n, n); } return integerDivide(n, m - 1) + integerDivide(n - m, m); } }","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://wangshengbo.me/tags/算法/"},{"name":"编程","slug":"编程","permalink":"http://wangshengbo.me/tags/编程/"},{"name":"递归","slug":"递归","permalink":"http://wangshengbo.me/tags/递归/"}],"keywords":[]},{"title":"网易：游戏任务标记问题","slug":"网易：游戏任务标记问题","date":"2017-10-03T08:26:55.309Z","updated":"2017-10-03T12:22:35.786Z","comments":true,"path":"2017/10/03/网易：游戏任务标记问题/","link":"","permalink":"http://wangshengbo.me/2017/10/03/网易：游戏任务标记问题/","excerpt":"","text":"在牛客网刷笔试题的时候看到过这样一道题，是网易的校招笔试题，题目描述如下： 游戏任务标记问题：游戏里面有很多各式各样的任务，其中有一种任务玩家只能做一次，这类任务一共有1024个，任务ID范围[1,1024]。请用32个unsigned int类型来记录着1024个任务是否已经完成。初始状态都是未完成。输入两个参数，都是任务ID，需要设置第一个ID的任务为已经完成；并检查第二个ID的任务是否已经完成。输出一个参数，如果第二个ID的任务已经完成输出1，如果未完成输出0。如果第一或第二个ID不在[1,1024]范围，则输出-1。 输入包括一行,两个整数表示任务ID.输出是否完成时间限制：1秒 空间限制：32768K 分析：每个无符号的int类型数据是4个字节，也就是32个bit位，那么32个无符号的int数据一共就有1024个bit位，正好对应1024个任务，每个bit位有1或0两种值，分别对应每个任务是否完成，1代表完成，0代表未完成。用一个长为32的int型数组存储这32个数，如何将1024个任务分成32个组并且很快能找到每个任务对应的bit位是十分关键的，我选择使用模运算来解决这个问题。若任务ID为N，则N % 32的结果（0~31）对应这个任务的完成情况存储在int数组的第几个整数里（int数组的下标，从0开始），以及在这个整数中的第几个bit位（二进制串的字符下标，从0开始）。例如：N = 34的时候，34 % 32 = 2，则这个任务对应的int数组下标为2，对应这个整数的二进制串的第三个bit位。 第一次AC的JAVA代码 public class GameMissionlabel { private int[] MI = new int[32]; public static void main(String[] args) { Scanner sc = new Scanner(System.in); GameMissionlabel gameMissionlabel = new GameMissionlabel(); while (sc.hasNext()) { //循环处理输入输出 String mission = sc.nextLine(); String[] ids = mission.split(&quot; &quot;); int id1 = Integer.parseInt(ids[0]); int id2 = Integer.parseInt(ids[1]); System.out.println(gameMissionlabel.checkmission(id1, id2)); } } private int checkmission(int id1, int id2) { if ((1 &lt;= id1 &amp;&amp; id1 &lt;= 1024) &amp;&amp; (1 &lt;= id2 &amp;&amp; id2 &lt;= 1024)) { // 计算位置 int bucket1 = id1 % 32; int bucket2 = id2 % 32; // 将整数转换成二进制字符数组 String binaryString1 = toBinaryString(MI[bucket1]); char[] binaryChar1 = binaryString1.toCharArray(); // 第一个任务设置成完成 binaryChar1[bucket1] = &#39;1&#39;; // 重构二进制字符串 String binaryString1New = String.valueOf(binaryChar1); // 将二进制字符串转换成整数，使用BigInteger是防止10000这样的串转换成int时出错 BigInteger b = new BigInteger(binaryString1New, 2); MI[bucket1] = b.intValue(); // 判断第二个任务是否完成 String binaryString2 = toBinaryString(MI[bucket2]); char[] binaryChar2 = binaryString2.toCharArray(); if (binaryChar2[bucket2] == &#39;0&#39;) { return 0; } else { return 1; } } else { return -1; } } private static String toBinaryString(int num) { String str = &quot;&quot;; // 0x80000000对应二进制1000 0000 0000 0000 0000 0000 0000 0000 for (int i = 0x80000000; i != 0; i &gt;&gt;&gt;= 1) { str += (num &amp; i) == 0 ? &#39;0&#39; : &#39;1&#39;; } return str; } } AC之后看了一下大神们写的代码，学到了一种最快的JAVA实现方式，对int进行二进制计算直接使用位运算符，能节省很多转换的操作。另外用BufferedReader比Scanner快10倍。代码如下： public class GameMissionlabel { public static int[] res = new int[32]; public static void main(String args[])throws Exception{ BufferedReader scanner = new BufferedReader(new InputStreamReader(System.in)); String [] str = scanner.readLine().split(&quot; &quot;); if(Integer.parseInt(str[0])&gt;1024||Integer.parseInt(str[0])&lt;1 ||Integer.parseInt(str[1])&gt;1024||Integer.parseInt(str[1])&lt;1){ System.out.println(-1); return; } //1. int pos = Integer.parseInt(str[0])%32; int mask=1; //对应二进制为00000000 00000000 00000000 00000001 mask&lt;&lt;=(31-pos); //将末尾的1移动至对应的位置，末尾自动补0 res[pos]|=mask; //使用按位或运算将1存储在整数中 //2. int pos2 = Integer.parseInt(str[1])%32; int mask2=1; mask2&lt;&lt;=(31-pos2); if((res[pos2]&amp;=mask2)!=0){ //使用按位与运算判断原整数中的任务状态 System.out.println(1); }else{ System.out.println(0); } } } 从这道题可以看出，自己对二进制计算不是很熟悉，需要做一个专题好好学习一下","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://wangshengbo.me/tags/算法/"},{"name":"编程","slug":"编程","permalink":"http://wangshengbo.me/tags/编程/"},{"name":"二进制计算","slug":"二进制计算","permalink":"http://wangshengbo.me/tags/二进制计算/"}],"keywords":[]},{"title":"爬楼梯问题（Fibonacci数列）","slug":"爬楼梯问题（Fibonacci数列）","date":"2017-10-03T03:31:06.378Z","updated":"2017-10-03T12:23:16.057Z","comments":true,"path":"2017/10/03/爬楼梯问题（Fibonacci数列）/","link":"","permalink":"http://wangshengbo.me/2017/10/03/爬楼梯问题（Fibonacci数列）/","excerpt":"","text":"在牛客网刷编程题的时候，遇到了一道爬楼梯问题，问题描述如下： You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 每一次能爬1或2级台阶，那么有多少种不同的方式爬上n级台阶？ 分析：n = 1的时候，只有一种方式（1）n = 2的时候，有两种方式（11,2）n = 3的时候，有3种方式（111,12,21）（n = 1的结果 + n = 2的结果）n = 4的时候，有5种方式（1111,22,211,121,112）（n = 3的结果 + n = 2的结果）……n = k的时候，有(n = k - 1的结果 + n = k - 2的结果)种方式则n的结果是Fibonacci数列 Java实现求解Fibonacci数列有两种方式，第一种是递归实现，代码如下 public int fibonacci(int n) { if (n &lt; 3) { return n; } return fibonacci(n-1)+fibonacci(n-2); } 递归实现的效率较差，因为很多递归的子问题都是相同的，但是却要重复计算 第二种实现方式是使用循环累加计算，代码如下 public int fibonacci(int n) { if (n &lt; 3) { return n; } int a = 1; int b=2; for (int i = 3; i &lt;= n; i++) { int mid = a; a = b; b = mid+a; } return b; } 这种实现方式每一位结果只计算一次，最后推算出最终结果，效率较高","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://wangshengbo.me/tags/算法/"},{"name":"编程","slug":"编程","permalink":"http://wangshengbo.me/tags/编程/"},{"name":"递归","slug":"递归","permalink":"http://wangshengbo.me/tags/递归/"}],"keywords":[]},{"title":"Hexo生成部署博文时报错YAMLException的解决方法","slug":"Hexo生成部署博文时报错YAMLException的解决方法","date":"2017-10-03T00:57:53.821Z","updated":"2017-10-03T01:02:39.632Z","comments":true,"path":"2017/10/03/Hexo生成部署博文时报错YAMLException的解决方法/","link":"","permalink":"http://wangshengbo.me/2017/10/03/Hexo生成部署博文时报错YAMLException的解决方法/","excerpt":"大家写完博文之后准备使用Hexo生成和部署的时候可能会遇到如下错误：","text":"大家写完博文之后准备使用Hexo生成和部署的时候可能会遇到如下错误： ERROR Process failed: _posts/边界安全防护学习笔记.md YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 5, column 1: ^ at generateError (E:\\wangshengbo.github.io\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:162:10) at throwError (E:\\wangshengbo.github.io\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:168:9) at readBlockMapping (E:\\wangshengbo.github.io\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:1040:9) at composeNode (E:\\wangshengbo.github.io\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:1326:12) at readDocument (E:\\wangshengbo.github.io\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:1488:3) at loadDocuments (E:\\wangshengbo.github.io\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:1544:5) at Object.load (E:\\wangshengbo.github.io\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:1561:19) at parseYAML (E:\\wangshengbo.github.io\\node_modules\\hexo\\node_modules\\hexo-front-matter\\lib\\front_matter.js:80:21) at parse (E:\\wangshengbo.github.io\\node_modules\\hexo\\node_modules\\hexo-front-matter\\lib\\front_matter.js:56:12) …………………… 上述错误是由于博文的yaml头部格式不正确导致的，正确的头部格式如下： title: yourtitle description: your description tags: - tag1 - tag2 categories: categorie1 --- 以下为正文 头部和正文之间要使用3个“-”进行分割，3个“-”与头部之间要有一个空行注意冒号后边要有空格，“-”符号前后都要有空格！title的内容中间不能有空格！","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://wangshengbo.me/tags/Hexo/"}],"keywords":[]},{"title":"边界安全防护学习笔记","slug":"边界安全防护学习笔记","date":"2017-09-30T01:36:01.671Z","updated":"2017-10-02T08:29:54.689Z","comments":true,"path":"2017/09/30/边界安全防护学习笔记/","link":"","permalink":"http://wangshengbo.me/2017/09/30/边界安全防护学习笔记/","excerpt":"信息安全等级保护（四级）中边界安全防护的技术要求边界完整性检查1、应能够检测内部网络中出现的内部用户未通过准许私自联到外部网络的行为，即“非法外联”行为。2、应能够对非授权设备私自联到网络的行为进行检查，并准确定位、有效阻断。3、应能够对内部网络用户私自联到外部网络的行为进行检查后准确定出位置，并对其进行有效阻断。4、应能够根据信息流控制策略和信息流的敏感标记阻止重要信息的流出。（网络设备标记，指定路由信息标记）","text":"信息安全等级保护（四级）中边界安全防护的技术要求边界完整性检查1、应能够检测内部网络中出现的内部用户未通过准许私自联到外部网络的行为，即“非法外联”行为。2、应能够对非授权设备私自联到网络的行为进行检查，并准确定位、有效阻断。3、应能够对内部网络用户私自联到外部网络的行为进行检查后准确定出位置，并对其进行有效阻断。4、应能够根据信息流控制策略和信息流的敏感标记阻止重要信息的流出。（网络设备标记，指定路由信息标记）网络入侵防范1、在网络边界处应监视以下攻击行为端口扫描、强力攻击、木马后门攻击、拒绝服务攻击、缓冲区溢出攻击、IP 碎片攻击、网络蠕虫攻击等入侵事件的发生。2、当检测到入侵事件时，应记录入侵的源IP、攻击的类型、攻击的目的、攻击的时间等并发出安全警告如可采取屏幕实时提示、E-mail 告警、声音告警等几种方式及自动采取相应动作。 恶意代码防范1、应在网络边界及核心业务网段处对恶意代码进行检测和清除。2、应维护恶意代码库的升级和检测系统的更新。3、应支持恶意代码防范的统一管理。 要点摘要1、针对内部用户非法外联进行检测、定位和阻断。————终端安全管理系统，提供非法外联监控功能。2、针对非授权设备非法内联进行检测、定位和阻断。————终端安全管理系统，利用IP/MAC绑定及ARP阻断功能实现非法接入控制。3、阻止重要信息流出（信息流控制策略、信息流的敏感标记、网络设备标记、指定路由信息标记）————防火墙、网闸4、应在网络边界部署访问控制设备，启用访问控制功能；应不允许数据带通用协议通过；应根据数据的敏感标记允许或拒绝数据通过；应不开放远程拨号访问功能。————防火墙5、入侵检测、记录、报警与处理————入侵检测系统6、恶意代码检测与清除————病毒过滤网关系统 第四级安全区域边界从以下方面进行安全设计1、区域边界访问控制：应在安全区域边界设置自主和强制访问控制机制，实施相应的访问控制策略，对进出安全区域边界的数据信息进行控制，阻止非授权访问。2、区域边界包过滤：应根据区域边界安全控制策略，通过检查数据包的源地址、目的地址、传输层协议、请求的服务等，确定是否允许该数据包进出受保护的区域边界。3、区域边界安全审计：应在安全区域边界设置审计机制，通过安全管理中心集中管理，对确认的违规行为及时报警并做出相应处置。4、区域边界完整性保护：应在区域边界设置探测器，例如外接探测软件，探测非法外联和入侵行为，并及时报告安全管理中心。 边界防护涉及到的设备和技术1、防火墙（访问控制ACL，不让坏的通过）2、UTM多重安全网关（IPS、AV）3、安全隔离与信息交换系统（网闸）（隔离、缓冲区、代理，让好的通过）4、数据交换网技术（综合使用缓冲区、代理、UTM、防火墙、网闸）","categories":[],"tags":[{"name":"信息安全","slug":"信息安全","permalink":"http://wangshengbo.me/tags/信息安全/"},{"name":"等级保护","slug":"等级保护","permalink":"http://wangshengbo.me/tags/等级保护/"}],"keywords":[]},{"title":"根据完全二叉树的节点数计算二叉树的深度","slug":"根据完全二叉树的节点数计算二叉树的深度","date":"2017-09-29T16:00:00.000Z","updated":"2017-10-03T12:22:50.185Z","comments":true,"path":"2017/09/30/根据完全二叉树的节点数计算二叉树的深度/","link":"","permalink":"http://wangshengbo.me/2017/09/30/根据完全二叉树的节点数计算二叉树的深度/","excerpt":"","text":"思路具有N个节点的完全二叉树的深度为$\\lfloor\\log_2 N\\rfloor+1$。 JAVA代码import java.util.Scanner; public class DeepOfTree { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int nodeNum; System.out.println(&quot;请输入完全二叉树的节点数：&quot;); nodeNum = scanner.nextInt(); int deep = (int) (Math.log(nodeNum) / Math.log(2)) + 1; System.out.println(&quot;完全二叉树的深度为：&quot;+deep); } }","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://wangshengbo.me/tags/算法/"},{"name":"二叉树","slug":"二叉树","permalink":"http://wangshengbo.me/tags/二叉树/"},{"name":"编程","slug":"编程","permalink":"http://wangshengbo.me/tags/编程/"}],"keywords":[]},{"title":"笔试编程题注意事项","slug":"笔试编程题注意事项","date":"2017-09-29T16:00:00.000Z","updated":"2017-10-02T08:29:46.064Z","comments":true,"path":"2017/09/30/笔试编程题注意事项/","link":"","permalink":"http://wangshengbo.me/2017/09/30/笔试编程题注意事项/","excerpt":"牛客网编程题注意事项Q:为什么代码在我本机可以通过，提交到牛客网总是提示答案错误A:牛客网的每个编程题都有10-50组测试数据，你的代码在本机可以通过仅仅是通过了样例数据，可能存在边界条件考虑不周导致更多的测试数据没有通过，所以会返回答案错误。还有一种可能是你的代码没有处理多个测试用例，例如A+B的代码需要while循环处理","text":"牛客网编程题注意事项Q:为什么代码在我本机可以通过，提交到牛客网总是提示答案错误A:牛客网的每个编程题都有10-50组测试数据，你的代码在本机可以通过仅仅是通过了样例数据，可能存在边界条件考虑不周导致更多的测试数据没有通过，所以会返回答案错误。还有一种可能是你的代码没有处理多个测试用例，例如A+B的代码需要while循环处理 C语言代码#include &lt;stdio.h&gt; int main() { int a,b; while(scanf(&quot;%d %d&quot;,&amp;a, &amp;b) != EOF) printf(&quot;%d&quot;,a+b); return 0; } JAVA代码import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; /* * 使用循环输入输出处理一次多组测试，记得在循环内清空数组、map、set等 * 注意输出结果的行末空格！！输出完全后要换行 * 注意算法时间复杂度 */ public class Main { public static void main(String[] args)throws IOException { Main main = new Main(); BufferedReader scanner = new BufferedReader(new InputStreamReader(System.in)); String str; while ((str = scanner.readLine()) != null) { //循环处理输入 String[] strings = str.split(&quot; &quot;); main.name(); for (String string : strings) { System.out.println(string); } } } public void name() { //除了输入输出以外的处理逻辑都放在方法里 } } Q:为什么Java代码在我本机运行正常，提交到牛客网报编译错误A: 因为Java文件名和类名需要保持一致。1、如果编程题已经提供了类和要编写代码的方法，请不要擅自给方法加上static，也不要擅自修改类的名字。也不要给代码增加任何package信息。2、对于没有提供任何辅助代码的编程题，请确认类的名字是Main Q:为什么我的代码在本机运行正常，提交到牛客网总是报运行超时A:牛客网对每个编程题的运行时间都有限制，一般是限制在1秒，牛客网后台判题的机器显然不如的你的台式机强劲，所以碰到超时请尽量优化你的代码效率。当然也有可能是你代码对某个测试用例死循环了 Q:为什么代码会提示答案正确（提交异常）A:这种情况代码本题你的结果是已AC，但是有点小问题：1、牛客网对提交的代码会做相似度的判断，如果发现你的代码通过的测试用例同时和已有代码相似度过高则会给出答案正确（提交异常）的提示2、根据题目的难易程度会对通过代码的提交频率进行控制，如果你提交通过代码的间隔太小，我们也认为有作弊可能，也会提示提交异常 Q:运行错误是什么情况A:运行错误一般都是数组越界非法访问，野指针乱访问，空指针乱访问等情况造成代码奔溃","categories":[],"tags":[{"name":"找工作","slug":"找工作","permalink":"http://wangshengbo.me/tags/找工作/"}],"keywords":[]},{"title":"OSI安全体系","slug":"OSI安全体系","date":"2016-10-19T13:40:27.799Z","updated":"2017-10-02T08:29:28.864Z","comments":true,"path":"2016/10/19/OSI安全体系/","link":"","permalink":"http://wangshengbo.me/2016/10/19/OSI安全体系/","excerpt":"OSI参考模型由下至上：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。","text":"OSI参考模型由下至上：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 安全服务 鉴别服务 访问控制服务 数据保密性服务 数据完整性服务 抗抵赖服务特定安全机制 加密 数字签名 访问控制 数据完整性 认证交换 业务流填充在应用连接空闲时，持续发送伪随机序列，使攻击者不知道哪些是有用信息，从而抵抗业务流量分析攻击。 路由选择控制选择物理上安全的子网络、中继站或链路。 公证由第三方公证人提供对通信数据的完整性、原发、时间和目的地等进行确保。普遍安全机制 可信功能度机制可信功能度用来度量扩充其他安全机制的范围或建立这些安全机制的有效性。任何功能度，只要它是直接提供安全机制，或提供对安全机制的访问，都应该是可信的。 安全标记机制对某一资源制定安全标记，明显或隐含。 事件检测机制 安全审计跟踪机制 安全恢复安全管理 与OSI有关的安全管理系统安全管理、安全服务管理、安全机制管理 OSI管理的安全管理的功能和通信的安全。 内容来源：《网络攻防技术教程——从原理到实践》（第一版）杜晔 张大伟 范艳芳 编著 武汉大学出版社","categories":[],"tags":[{"name":"信息安全","slug":"信息安全","permalink":"http://wangshengbo.me/tags/信息安全/"}],"keywords":[]},{"title":"知道创宇研发技能表v3.1","slug":"知道创宇研发技能表v3.1","date":"2016-10-19T13:13:24.885Z","updated":"2017-10-02T08:30:34.816Z","comments":true,"path":"2016/10/19/知道创宇研发技能表v3.1/","link":"","permalink":"http://wangshengbo.me/2016/10/19/知道创宇研发技能表v3.1/","excerpt":"","text":"知道创宇研发技能表原文链接","categories":[],"tags":[{"name":"找工作","slug":"找工作","permalink":"http://wangshengbo.me/tags/找工作/"}],"keywords":[]},{"title":"安全工程师职位要求","slug":"安全工程师职位要求","date":"2016-10-19T13:13:14.307Z","updated":"2017-10-02T08:29:18.145Z","comments":true,"path":"2016/10/19/安全工程师职位要求/","link":"","permalink":"http://wangshengbo.me/2016/10/19/安全工程师职位要求/","excerpt":"（本职位要求来源于各大招聘网站，并进行整理，不断更新中）最近整理了一下各大招聘网站上的安全工程师的职位要求，从理论到技术，从软件到硬件，还包括百度、阿里和知道创宇等公司的职位要求。","text":"（本职位要求来源于各大招聘网站，并进行整理，不断更新中）最近整理了一下各大招聘网站上的安全工程师的职位要求，从理论到技术，从软件到硬件，还包括百度、阿里和知道创宇等公司的职位要求。 理论与技术 精通计算机网络，具备网络故障的分析、判断、解决能力； 精通网络安全技术:包括端口、服务漏洞扫描、程序漏洞分析检测、权限管理、入侵和攻击分析追踪、网站渗透、病毒木马防范等； 精通php/shell/perl/python/c/c++ 等至少一种语言;应用与系统 熟悉windows或linux系统 熟练运用server2008、2012等对服务器进行维护与管理； 了解主流网络安全产品(如fw、ids、scanner、audit等)的配置及使用;硬件与设备 熟悉主流路由器及核心交换及防火墙配置管理、监测； 精通LAN/WAN网络规划及建设，精通局域网的维护，可熟练进行局域网的搭建； 了解常见网络设备（包括网络安全设备）的工作原理、网络设备的基本维护和故障处理； 熟悉和掌握各种计算机软硬件，可独立进行安装、调试及故障排除； 百度安全工程师校园招聘 工作职责: 参与安全漏洞跟进处理、安全事件与0Day应急响应，及时感知/挖掘安全风险 参与公司整体及云计算、大数据、互联网金融等重点业务的安全策略与规范的制定，结合安全技术与运营推动人员安全意识提升和安全风险的缓解，参与安全运营平台化 参与公司各业务，尤其是金融、云计算、大数据、移动等方向业务的安全设计评审、安全测试与评估 参与公司（云）安全产品的设计、维护、及核心能力的持续提升，比如漏洞云扫描、云WAF、基于大数据的多层入侵监控与威胁感知、代码与环境安全质量控制等 参与对公司内部、重点业务（如云计算）相关的渗透测试，参与研究漏洞挖掘及利用技术，为不断完善提升公司安全防御及云安全服务能力提供技术驱动力 职责要求: 具备基本的计算机技术基础（基本网络协议、基本编程能力） 有漏洞挖掘或代码安全审计经验 有渗透测试经验（熟悉典型漏洞的发现与利用） 具备基本的安全漏洞修复与攻击防御知识 追求卓越，不甘平庸，具备强烈的事业心和开拓创新精神 优秀的沟通能力以及团队合作精神 有下列相关经验者优先： 有大型互联网企业实习经验者优先； 有专注于漏洞挖掘与利用技术研究者优先； 有大型互联网渗透经验者优先。 阿里安全工程师校园招聘 岗位描述 从web安全到底层系统安全，从客户端安全到无线产品安全，从安全规范制定到实时应急响应，一切的努力都为了更安全！ 岗位要求 熟识计算机网络，具备Linux环境下C/C++开发能力，至少掌握perl/python/shell一种脚本语言；如果你熟知web安全，了解当前流行的web漏洞（XSS, SQL Injection, CSRF, etc），了解java开发框架（Struts,spring,ibatis,hibernate,etc）； 具备windows客户端安全攻防的经验，或了解Android/iOS无线客户端安全； 了解Linux系统管理和网络管理相关操作，了解Linux系统的安全漏洞，有Linux exploit code/shellcode编写经验； 熟悉TCP/IP协议栈和路由交换原理，熟悉企业级服务器安全； 知道创宇404安全研究员 岗位职责： 国内外安全技术的跟进和重现，包括：操作系统安全漏洞、WEB应用安全漏洞、IoT类设备安全漏洞 根据自身研究方向研究系统原理和漏洞原理 为公司安全产品提供代码级技术原型支持 对业界目前的攻击和防御办法进行研究和跟踪，研究新的攻击和防御方法 职位要求： 具备一些漏洞研究的能力，能够理解漏洞原理 对于安全技术有深厚的兴趣，并且希望投入主要精力进行跟进和研究 有编程思维，C/C++、python、java、ruby或其他脚本编程语言至少一种，通过一定时间的工作积累可以写一些辅助测试工具 对各类领域的新技术感兴趣，善用Google，愿意花时间阅读E文文档 具有良好的沟通能力、协调能力、理解能力，并拥有强烈的责任心和团队管理能力，能承受一定强度的工作压力 喜欢研究安全技术，愿意花大量时间完成某项安全测试 能够深入到操作系统底层理解漏洞为加分项 知道创宇安全研究员（实习） 职位要求：1.至少精通一门脚本语言；2.熟习各种Web安全攻防手法；3.精通WEB应用程序渗透测试方法和定制攻击自动化；4.深入理解OWASP风险评估中前十位Web攻击模式和评估方法；5.知道如何跟踪最新的Web安全信息动态；6.善于挖掘Web安全漏洞或有安全工具开发经验者优先；7.对Web安全有浓厚的兴趣和较强的独自钻研能力，有良好的团队精神。 知道创宇前端安全研究员（实习） 岗位职责1、对主流浏览器进行前端漏洞挖掘2、对主流Web系统进行前端漏洞挖掘 职位要求1、擅长Linux/Unix系统操作，以Linux/Mac作为工作平台2、熟悉JavaScript、Jquery等，能够独立编写漏洞利用程序3、掌握JavaScript及IE、Safari、Chrome、FireFox、Thunder Bird、Opera等主流浏览器，能够有针对性的进行XSS、ClickJacking和CSRF 优先条件1、有实战经验者优先。2、在著名白帽子类网站发表过严重的信息安全漏洞3、在各类信息安全大会上有过个人主题演讲4、在各类信息安全攻防类大赛上获得过集体或个人奖项","categories":[],"tags":[{"name":"信息安全","slug":"信息安全","permalink":"http://wangshengbo.me/tags/信息安全/"},{"name":"找工作","slug":"找工作","permalink":"http://wangshengbo.me/tags/找工作/"}],"keywords":[]},{"title":"漏洞扫描","slug":"漏洞扫描","date":"2016-10-19T13:12:57.867Z","updated":"2017-10-02T08:30:22.897Z","comments":true,"path":"2016/10/19/漏洞扫描/","link":"","permalink":"http://wangshengbo.me/2016/10/19/漏洞扫描/","excerpt":"漏洞扫描方法 在端口扫描后得知目标主机操作系统类型、开启的端口以及端口上的网络服务，将这些相关信息与网络漏洞扫描系统提供的漏洞裤进行匹配，查看是否有满足匹配条件的漏洞存在 通过模拟黑客的攻击手法，对目标主机系统进行攻击性的安全漏洞扫描，如测试弱口令等。若模拟攻击成功，则表明目标主机系统存在安全漏洞。","text":"漏洞扫描方法 在端口扫描后得知目标主机操作系统类型、开启的端口以及端口上的网络服务，将这些相关信息与网络漏洞扫描系统提供的漏洞裤进行匹配，查看是否有满足匹配条件的漏洞存在 通过模拟黑客的攻击手法，对目标主机系统进行攻击性的安全漏洞扫描，如测试弱口令等。若模拟攻击成功，则表明目标主机系统存在安全漏洞。 漏洞扫描的分类扫描对象： 基于网络的扫描从外部攻击者的角度对网络及系统架构进行的扫描，主要用于查找网络服务和协议中的漏洞。基于网络的漏洞扫描工具根据不同漏洞的特性，构造网络数据包，发给网络中的一个或多个目标服务器，以判断某个特定的漏洞是否存在。 基于主机的扫描从一个内部用户的角度来检测操作系统级的漏洞（主要用于检测注册表和用户配置中的漏洞）。扫描器通常在目标系统上安装一个代理或服务，以便能够访问所有的文件与进程。优势在于能直接获取主机操作系统的底层细节（如特殊服务和配置的细节等），缺点在于需要先控制目标主机并安装检测工具。 扫描方式： 主动扫描给目标主机发送特定的包并收集回应包来取得相关信息。优势：快速获取信息，准确性高。缺点：易于被发现，难掩盖扫描痕迹，突破防火墙比较困难。 被动扫描通过监听网络包来取得信息。优势：难以被检测，不易受防火墙影响。缺点：速度慢，准确性差，目标不产生网络流量时无法获得信息。 内容来源：《网络攻防技术教程——从原理到实践》（第一版）杜晔 张大伟 范艳芳 编著 武汉大学出版社","categories":[],"tags":[{"name":"信息安全","slug":"信息安全","permalink":"http://wangshengbo.me/tags/信息安全/"}],"keywords":[]},{"title":"网络嗅探","slug":"网络嗅探","date":"2016-10-19T13:12:21.089Z","updated":"2017-10-02T08:30:28.721Z","comments":true,"path":"2016/10/19/网络嗅探/","link":"","permalink":"http://wangshengbo.me/2016/10/19/网络嗅探/","excerpt":"嗅探器SnifferSniffer是利用计算机的网络接口截获目的地为其他计算机数据报文的一种工具，可以用来监视网络的状态、数据流动情况以及网络上传输的信息。 FTP、Telnet、SMTP、POP等协议使用明文传输数据。 局域网可分为共享式局域网与交换式局域网。 共享式局域网使用集线器（Hub），工作在物理层，把一个端口接收到的信号向所有其他端口分发。 交换式局域网使用交换机（Switch），能够检查数据包中的目标物理地址来选择目标端口，从而将数据只转发到与该目标端口相连的主机或设备中。 Sniffer只能抓取一个物理网段内的包，你和监听的目标中间不能有路由或其他屏蔽广播包的设备。 Sniffer分为硬件和软件两种，软件Sniffer无法抓取网络上所有的传输。","text":"嗅探器SnifferSniffer是利用计算机的网络接口截获目的地为其他计算机数据报文的一种工具，可以用来监视网络的状态、数据流动情况以及网络上传输的信息。 FTP、Telnet、SMTP、POP等协议使用明文传输数据。 局域网可分为共享式局域网与交换式局域网。 共享式局域网使用集线器（Hub），工作在物理层，把一个端口接收到的信号向所有其他端口分发。 交换式局域网使用交换机（Switch），能够检查数据包中的目标物理地址来选择目标端口，从而将数据只转发到与该目标端口相连的主机或设备中。 Sniffer只能抓取一个物理网段内的包，你和监听的目标中间不能有路由或其他屏蔽广播包的设备。 Sniffer分为硬件和软件两种，软件Sniffer无法抓取网络上所有的传输。 对共享式网络的嗅探Sniffer将网卡的工作模式由正常改变为混杂模式，就可以对所有监听到的数据帧都产生一个硬件中断并提交给主机进行处理。设置混杂模式可能需要root权限。 对交换式网络的嗅探 ARP欺骗 1.Windows中使用arp -a命令查看ARP缓存表。 2.在动态ARP实现中，任何ARP响应分组都可以刷新ARP缓存表中的记录，而不管这个ARP分组是否是对一个ARP请求分组的应答。 3.如果要欺骗整个网络，伪造包的目的MAC地址改为FF:FF:FF:FF:FF:FF；目的IP地址改为FF:FF:FF:FF；源IP地址改为网关的IP，源MAC地址仍为本机地址，同时欺骗网关，并做好数据包的转发。 交换机MAC地址表溢出地址表是MAC地址——交换机端口转换表，地址表大小有上限，溢出之后交换机会广播所有数据包。此时相当于集线器，网络变为共享式。 MAC地址伪造若交换机转发表是动态更新，并采用牛奶策略。攻击者不断发送数据包，并把源MAC地址改为攻击目标的地址，从而不断更新交换机转发表。 ICMP重定向攻击ICMP重定向包用来告诉机器向另一个不同的路由器（或机器）发送它的数据包。除了路由器的主机必须服从ICMP重定向。嗅探器的检测与防范 主动检测 ARP广播地址探测在混乱模式时，网卡检测收到包的目的以太网的第一个八位组值，若是0xFF，则认为是广播地址。因此发送一个目的地址为FF-00-00-00-00-00的ARP包，如果某主机以自己的MAC地址回应这个包，那么它运行在混杂模式下。 ping方法向可疑主机发送包含正确IP地址和错误MAC地址的Ping包，如果回应，则该主机在运行嗅探器程序。 DNS方法（不懂……）一些嗅探器在收到一个网络请求时，就会执行DNS反向查询，试着将IP地址解释为主机名。因此，如果你在网络中执行一个Ping扫描或者Pinging一个不存在的IP地址，就会触发这种活动。如果得到了回应，就说明网络中安装有网络嗅探器，如果没有收到任何回应，表明没有嗅探器在运行。 源路径方法这种方法在IP头中配置源路由信息,可以用于其它临近网段,具体步骤如下:①设A为可疑主机,B为检测主机,C为同一网段的另一台主机,C不具有转发功能。②B发送数据给A,设置为必须经过C。③如果能接收到数据的响应信息,那么查看TTL值域,如果不变,说明A运行嗅探器程序。B发给A的数据事实上发给C,由于C不具有转发功能,所以数据不能到达A,但是由于A运行了嗅探器程序,所以才能接收到数据。 诱骗方法 网络带宽出现反常 网络通信丢包率高 等待时间方法这种方法在网络中发送大量数据,这对设置在非混杂模式的机器没有影响,但是对运行嗅探器程序的机器有影响。特别是用于口令的语法分析应用层协议。只要在未发送数据之前以及发送数据之后PING主机,对比两次的响应时间差别就可以检测。这种方法很有效,不过可能明显降低网络性能。 使用检测工具Anti-sniff等 被动防范 安全的拓扑结构 会话加密 使用静态的ARP或者IP-MAC对应表 内容来源：《网络攻防技术教程——从原理到实践》（第一版）杜晔 张大伟 范艳芳 编著 武汉大学出版社","categories":[],"tags":[{"name":"信息安全","slug":"信息安全","permalink":"http://wangshengbo.me/tags/信息安全/"}],"keywords":[]},{"title":"不积跬步，无以至千里","slug":"不积跬步，无以至千里","date":"2016-09-25T08:09:51.162Z","updated":"2017-10-02T08:30:00.425Z","comments":true,"path":"2016/09/25/不积跬步，无以至千里/","link":"","permalink":"http://wangshengbo.me/2016/09/25/不积跬步，无以至千里/","excerpt":"","text":"这个周末解锁了好多新成就，第一次搭建个人博客…第一次使用Hexo…第一次使用MarkDown…不过这些成就早就该解锁了，这些计划已经写下了很久了。作为一名计算机专业的大学生，读研之后才有了自己的博客，对自己的拖延癌症晚期深刻的检讨一下……说真的，域名买了好久，到现在才真正能够访问，而且自己一直想做的个人主页还没有雏形……之前数次想行动，到最终还是搁置了下来。 零零碎碎学了各种各样的知识，开发、系统、安全等等。无论是编程语言还是系统模型，到最后要用到的时候还是无法回忆起具体的内容，其他同学心中烂熟的概念我还没建立起来。可能是我的记忆力确实差吧，再加上没有深入的实践和应用。所以必须要把自己学到的点点滴滴的知识记录整理下来，慢慢的积累，方便自己随时查看并纠正自己之前的错误。这也是搭建个人博客的初衷所在。 之前的设想是自己从头写一个完整的博客系统，最后实践时才发现是多么的困难，而且写出能用的博客系统不知道要哪年哪月，主要是自己真的菜……所以图省事采用了Hexo和Github Pages来搭建博客，也想尽快能够使用博客。现在博客系统还有许多需要修改的地方，以后慢慢的调整吧，距离自己印象中的样子差太远啦。 想学的东西好多好多，想做的东西也很多，想玩的东西更多，脚踏实地吧。 不积跬步，无以至千里，想在信息安全的路上走的再远一点。","categories":[],"tags":[{"name":"散记","slug":"散记","permalink":"http://wangshengbo.me/tags/散记/"}],"keywords":[]}]}